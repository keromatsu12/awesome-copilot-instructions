---
name: State Management
description: アプリケーションの状態管理に関する戦略。ローカルステート、グローバルステート、サーバーキャッシュの使い分けと、ZustandやReact Contextなどの適切なツールの選択について解説します。
---

## Directory Structure

```
github/skills/state-management/
├── assets/       # 画像や図などのリソース
├── examples/     # 実装例やサンプルコード
├── references/   # 参考文献やリンク
├── scripts/      # 関連するスクリプト
├── templates/    # テンプレートファイル
└── SKILL.md      # このファイル
```

## When to Use

*   複数のコンポーネント間でデータを共有する必要がある際
*   複雑なインタラクションやUIの状態遷移を管理する際
*   ユーザー設定、認証情報、テーマなどのグローバルな値を保持する際
*   フォーム入力など、一時的なデータの保持を行う際

## Quick Start

1.  **スコープの判断**: その状態（state）が「どこで必要か」を判断します。特定のコンポーネントだけで完結するならローカルステート、アプリ全体で必要ならグローバルステートを選択します。
2.  **種類の判断**: そのデータが「サーバーから来たもの（Server State）」か「クライアントで生成したもの（Client State）」かを区別します。
3.  **ツールの選択**:
    *   **Server State**: TanStack Query (React Query) などのデータフェッチライブラリに任せます。
    *   **Local UI State**: `useState`, `useReducer` を使用します。
    *   **Global UI State**: Zustand や React Context を使用します。
4.  **実装**: 選択したツールを用いてストアやフックを実装し、コンポーネントから利用します。

## Guidelines

### 1. State Colocation (状態の局所化)

**「状態は可能な限りそれを使用するコンポーネントの近くに置く」** ことが基本原則です。
安易にすべての状態をグローバル（ReduxやZustandのストア）に入れると、再レンダリングの範囲が広がり、依存関係が複雑になります。
まずは `useState` から始め、Props Drilling（バケツリレー）が辛くなった時点でリフトアップやグローバル化を検討します。

### 2. Server State vs Client State

サーバーから取得したデータ（ユーザーリスト、商品情報など）と、クライアントで管理するUIの状態（モーダルの開閉、入力中のフォーム値）は明確に区別して管理します。
サーバー状態の管理には、キャッシュ、再取得、同期機能を持つ専用ライブラリ（TanStack Queryなど）を使用し、自前の `useEffect` + `useState` で管理することを避けます。

### 3. グローバル状態管理の選択

アプリ全体で共有すべき状態（Client State）には、以下のツールを使い分けます。
*   **Zustand**: シンプルでボイラープレートが少なく、パフォーマンス（不要な再レンダリングの抑制）に優れているため、多くのケースで推奨されます。
*   **React Context**: テーマ切り替えや言語設定など、更新頻度が低く、広範囲に配信する静的な値に適しています。頻繁に更新される値に使うと、配下のコンポーネントが不要に再レンダリングされる可能性があります。

### 4. 不変性 (Immutability)

状態を更新する際は、元のオブジェクトを直接変更（破壊的変更）せず、新しいオブジェクトを作成して置き換える（不変性を保つ）必要があります。これにより、Reactの再レンダリング検知が正しく機能し、予測可能な動作となります。

## Templates

*   `templates/`: Zustandストアやカスタムフックのテンプレートが含まれます。
